<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>âš¡ æ¿€å…‰å¤§å†’é™©100</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            font-family: 'Microsoft YaHei', sans-serif;
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh; padding: 10px; overflow: hidden;
        }
        #gameTitle {
            color: #00d4ff; text-shadow: 0 0 20px #00d4ff;
            font-size: 22px; margin-bottom: 8px;
        }
        #gameInfo {
            display: flex; gap: 12px; color: #fff; margin-bottom: 8px;
            font-size: 13px; flex-wrap: wrap; justify-content: center;
        }
        .info-item {
            background: rgba(0, 212, 255, 0.15); padding: 4px 10px;
            border-radius: 15px; border: 1px solid rgba(0, 212, 255, 0.3);
        }
        #gameCanvas {
            border: 2px solid #00d4ff; border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
            background: #0a0a0a; max-width: 100%; max-height: 50vh;
        }
        #controls { margin-top: 8px; display: flex; flex-direction: column; align-items: center; gap: 6px; }
        #dPad { display: grid; grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(3, 50px); gap: 3px; }
        .dBtn {
            width: 50px; height: 50px; border: none; border-radius: 8px;
            background: linear-gradient(145deg, #00d4ff, #0099cc); color: white;
            font-size: 20px; cursor: pointer; user-select: none;
        }
        .dBtn:active { transform: scale(0.92); }
        #btnUp { grid-column: 2; grid-row: 1; }
        #btnLeft { grid-column: 1; grid-row: 2; }
        #btnRight { grid-column: 3; grid-row: 2; }
        #btnDown { grid-column: 2; grid-row: 3; }
        button {
            padding: 8px 25px; font-size: 14px; border: none; border-radius: 20px;
            cursor: pointer; margin: 0 5px;
        }
        #actionBtn { background: linear-gradient(145deg, #ff6b6b, #ee5a5a); color: white; }
        #actionBtn:hover { transform: scale(1.05); }
        .screen {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; background: rgba(10, 10, 20, 0.98);
            padding: 25px; border-radius: 15px; border: 2px solid #00d4ff;
            display: none; z-index: 100; max-width: 90vw; max-height: 90vh; overflow-y: auto;
        }
        .screen h2 { color: #00d4ff; margin-bottom: 15px; font-size: 22px; }
        .screen p { margin: 8px 0; font-size: 13px; }
        .screen button { background: linear-gradient(145deg, #00d4ff, #0099cc); color: white; }
        #startScreen { display: block; }
        .shop-item {
            background: rgba(255, 215, 0, 0.1); border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px; padding: 12px; margin: 8px; cursor: pointer; display: inline-block;
        }
        .shop-item:hover { background: rgba(255, 215, 0, 0.2); }
        .name-input {
            padding: 10px 15px; font-size: 14px; border: 2px solid #00d4ff; border-radius: 20px;
            background: rgba(0, 212, 255, 0.1); color: white; text-align: center; margin: 10px 0;
        }
        input[type="range"] {
            -webkit-appearance: none; width: 200px; height: 8px; border-radius: 4px;
            background: rgba(0, 212, 255, 0.3); outline: none; margin: 10px 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%;
            background: #00d4ff; cursor: pointer; box-shadow: 0 0 10px #00d4ff;
        }
        table { width: 100%; border-collapse: collapse; font-size: 12px; margin: 10px 0; }
        th { background: rgba(255, 107, 157, 0.2); padding: 8px; color: #ff6b9d; }
        td { padding: 6px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        #lbContent { max-height: 280px; overflow-y: auto; margin: 10px 0; }
    </style>
</head>
<body>
    <h1 id="gameTitle">âš¡ æ¿€å…‰å¤§å†’é™©100</h1>
    <div id="gameInfo">
        <span class="info-item">â¤ï¸ <span id="lives">5</span></span>
        <span class="info-item">â±ï¸ <span id="timer">60</span>s</span>
        <span class="info-item">ğŸ¯ <span id="level">1</span>/100</span>
        <span class="info-item">ğŸª™ <span id="coins">0</span></span>
        <span class="info-item" id="progressBox" style="display:none">ğŸ“œ <span id="progress">0</span>%</span>
    </div>
    
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    
    <div id="controls">
        <div id="dPad">
            <button class="dBtn" id="btnUp">â–²</button>
            <button class="dBtn" id="btnLeft">â—€</button>
            <button class="dBtn" id="btnRight">â–¶</button>
            <button class="dBtn" id="btnDown">â–¼</button>
        </div>
        <button id="actionBtn">å¼€å§‹æ¸¸æˆ</button>
    </div>
    
    <!-- å…³å¡é€‰æ‹©ç•Œé¢ -->
    <div id="levelSelectScreen" class="screen">
        <h2>ğŸ¯ é€‰æ‹©èµ·å§‹å…³å¡</h2>
        <p style="color:#888">å·²è§£é”å…³å¡: 1-<span id="selectMaxLevel">1</span></p>
        <div style="margin:20px 0;">
            <input type="range" id="levelSlider" min="1" max="1" value="1" style="width:250px;" oninput="document.getElementById('selectedLevel').textContent=this.value">
            <p style="font-size:28px;color:#00d4ff;margin-top:10px;">ç¬¬ <span id="selectedLevel">1</span> å…³</p>
        </div>
        <button onclick="confirmStartLevel()">å¼€å§‹æ¸¸æˆ</button>
        <button onclick="backToMenu()" style="background:#666">è¿”å›</button>
    </div>
    
    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="startScreen" class="screen">
        <h2>âš¡ æ¿€å…‰å¤§å†’é™©100</h2>
        <p>ğŸ® 100å…³æŒ‘æˆ˜ | ğŸ’£ 5å…³åæœ‰ç‚¸å¼¹</p>
        <p>ğŸ›’ æ¯10å…³å•†åº— | ğŸ“œ 20å…³åå·è½´</p>
        <p style="color:#ff6b6b">ğŸ”´-1 ğŸŸ -2 ğŸŸ¡-3 ğŸŸ¢-4 ğŸ”µ-5</p>
        <button onclick="showLevelSelect()">å¼€å§‹æŒ‘æˆ˜</button>
        <button onclick="showLeaderboard()" style="background:linear-gradient(145deg,#ff6b9d,#ff4081)">ğŸ† æ’è¡Œ</button>
    </div>
    
    <!-- å•†åº—ç•Œé¢ -->
    <div id="shopScreen" class="screen">
        <h2>ğŸ›’ å•†åº—</h2>
        <p style="color:#ffd700;font-size:16px">ğŸª™ <span id="shopCoins">0</span></p>
        <div id="shopItems"></div>
        <button onclick="closeShop()">ç»§ç»­</button>
    </div>
    
    <!-- æ¸¸æˆç»“æŸ -->
    <div id="gameOverScreen" class="screen">
        <h2 id="goTitle">æ¸¸æˆç»“æŸ</h2>
        <p id="goStats"></p>
        <input type="text" id="playerName" class="name-input" placeholder="è¾“å…¥åå­—" maxlength="8"><br>
        <button onclick="submitScore()">æäº¤åˆ†æ•°</button>
        <button onclick="showLevelSelect()" style="background:linear-gradient(145deg,#00d4ff,#0099cc)">é€‰æ‹©å…³å¡</button>
        <button onclick="skipSubmit()" style="background:#666">è¿”å›ä¸»èœå•</button>
    </div>
    
    <!-- æ’è¡Œæ¦œ -->
    <div id="lbScreen" class="screen">
        <h2>ğŸ† æ’è¡Œæ¦œ</h2>
        <div id="lbContent"></div>
        <button onclick="hideLeaderboard()">è¿”å›</button>
    </div>

    <script>
        // åŸºç¡€è®¾ç½®
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // æœ€å¤§ç”Ÿå‘½å€¼
        let maxLives = 5;
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = 'start';
        let level = 1, lives = 5, coins = 0;
        let levelTime = 60, totalTime = 0;
        let lastTime = 0, timerInterval = null;
        let isScrolling = false, worldW = 600, camX = 0;
        
        // ç©å®¶
        const player = { x: 50, y: 180, size: 18, speed: 3, dizzy: 0, shield: 0 };
        
        // èµ·ç‚¹ç»ˆç‚¹
        const startPt = { x: 30, y: 180, w: 40, h: 40 };
        const endPt = { x: 530, y: 180, w: 40, h: 40 };
        
        // æ¸¸æˆå¯¹è±¡æ•°ç»„
        let lasers = [], bombs = [], coinList = [], particles = [];
        
        // é“å…·åº“å­˜
        const items = { speed: 0, shield: 0, life: 0, time: 0 };
        
        // è¾“å…¥
        const keys = {};
        
        // æ¿€å…‰é¢œè‰²
        const L_COLORS = ['#ff0000', '#ff8800', '#ffdd00', '#00ff00', '#0088ff'];
        const L_DAMAGE = [1, 2, 3, 4, 5];
        
        // æ’è¡Œæ¦œ
        let lb = JSON.parse(localStorage.getItem('lb100') || '[]');
        
        // æœ€é«˜å…³å¡è®°å½•
        let maxLevelReached = parseInt(localStorage.getItem('maxLevel100') || '1');
        
        // ä¿å­˜æœ€é«˜å…³å¡
        function saveMaxLevel(lvl) {
            if (lvl > maxLevelReached) {
                maxLevelReached = lvl;
                localStorage.setItem('maxLevel100', maxLevelReached);
            }
        }
        
        // ==================== ç±»å®šä¹‰ ====================
        
        class Laser {
            constructor(x, y, w, h, typeIdx, interval, offset) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.typeIdx = typeIdx; this.active = false;
                this.timer = offset || 0; this.interval = interval;
            }
            update(dt, lvl) {
                this.timer += dt;
                const spd = 1 + (lvl - 1) * 0.08;
                if (this.timer >= this.interval / spd) {
                    this.active = !this.active; this.timer = 0;
                }
            }
            draw() {
                const cw = canvas.width;
                const ch = canvas.height;
                if (this.x + this.w < 0 || this.x > cw) return;
                ctx.save();
                const c = L_COLORS[this.typeIdx];
                
                // å…³é”®æ¿€å…‰ç‰¹æ®Šè§†è§‰æ•ˆæœ
                if (this.isKey) {
                    if (this.active) {
                        // å…³é”®æ¿€å…‰å¼€å¯ï¼šçº¢è‰²è„‰å†²è¾¹æ¡†
                        ctx.shadowBlur = 25; ctx.shadowColor = '#ff0000';
                        ctx.fillStyle = c; ctx.fillRect(this.x, this.y, this.w, this.h);
                        // è„‰å†²è¾¹æ¡†
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x - 1, this.y - 1, this.w + 2, this.h + 2);
                    } else {
                        // å…³é”®æ¿€å…‰å…³é—­ï¼šæ·±çº¢è‰²è™šçº¿æ¡†ï¼ˆä»å¯è¾¨è®¤ï¼‰
                        ctx.fillStyle = c + '30';
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                        ctx.strokeStyle = '#ff0000';
                        ctx.setLineDash([3, 3]);
                        ctx.lineWidth = 1;
                        ctx.strokeRect(this.x, this.y, this.w, this.h);
                    }
                } else {
                    // è¾…åŠ©æ¿€å…‰æ™®é€šæ ·å¼
                    if (this.active) {
                        ctx.shadowBlur = 15; ctx.shadowColor = c;
                        ctx.fillStyle = c; ctx.fillRect(this.x, this.y, this.w, this.h);
                    } else {
                        ctx.fillStyle = c + '40';
                        ctx.setLineDash([5, 5]);
                        ctx.strokeStyle = c + '60';
                        ctx.fillRect(this.x, this.y, this.w, this.h);
                        ctx.strokeRect(this.x, this.y, this.w, this.h);
                    }
                }
                ctx.restore();
            }
            hit(px, py) {
                if (!this.active) return 0;
                // px æ˜¯ player.xï¼ˆä¸–ç•Œåæ ‡ï¼‰ï¼Œthis.x ä¹Ÿæ˜¯ä¸–ç•Œåæ ‡ï¼Œä¸éœ€è¦åŠ  camX
                return (px < this.x + this.w && px + player.size > this.x &&
                        py < this.y + this.h && py + player.size > this.y) ? L_DAMAGE[this.typeIdx] : 0;
            }
        }
        
        class Bomb {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = 22;
                this.t = 0; 
                this.fuseTime = 0; // å¼•ä¿¡æ—¶é—´
                this.fuseStarted = false;
                this.exploding = false; 
                this.r = 0; this.maxR = 70;
                this.hasDamaged = false; // æ˜¯å¦å·²ç»é€ æˆè¿‡ä¼¤å®³
            }
            update(dt) {
                this.t += dt;
                
                // å¼•ä¿¡å€’è®¡æ—¶
                if (this.fuseStarted && !this.exploding) {
                    this.fuseTime -= dt;
                    if (this.fuseTime <= 0) {
                        this.exploding = true;
                    }
                }
                
                if (this.exploding) {
                    this.r += 4;
                    return this.r < this.maxR;
                }
                return true;
            }
            draw() {
                const cw = canvas.width;
                if (this.x + this.size < 0 || this.x > cw) return;
                if (this.exploding) {
                    const g = ctx.createRadialGradient(this.x + 11, this.y + 11, 0, this.x + 11, this.y + 11, this.r);
                    g.addColorStop(0, 'rgba(255,100,0,0.8)'); g.addColorStop(1, 'rgba(255,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(this.x + 11, this.y + 11, this.r, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.save();
                    ctx.shadowBlur = 12; ctx.shadowColor = '#ff4400';
                    ctx.fillStyle = '#333'; ctx.fillRect(this.x, this.y, this.size, this.size);
                    
                    // å¼•ä¿¡å¯åŠ¨åå¿«é€Ÿé—ªçƒ
                    if (this.fuseStarted) {
                        const flash = Math.sin(this.t / 50) > 0;
                        ctx.fillStyle = flash ? '#ff0000' : '#ffff00';
                    } else {
                        const flash = Math.sin(this.t / 150) > 0;
                        ctx.fillStyle = flash ? '#ff0000' : '#ff8800';
                    }
                    
                    ctx.fillRect(this.x + 4, this.y + 4, this.size - 8, this.size - 8);
                    
                    // æ˜¾ç¤ºå¼•ä¿¡å€’è®¡æ—¶
                    if (this.fuseStarted) {
                        const cd = Math.ceil(this.fuseTime / 1000);
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
                        ctx.fillText(cd, this.x + 11, this.y + 17);
                    } else if (this.t > 2000) {
                        const cd = Math.ceil((3000 - this.t) / 1000);
                        if (cd > 0) { ctx.fillStyle = '#fff'; ctx.font = 'bold 11px Arial'; ctx.textAlign = 'center'; ctx.fillText(cd, this.x + 11, this.y + 16); }
                    }
                    ctx.restore();
                }
            }
            trigger(px, py) {
                const dx = (px+player.size/2)-(this.x+11), dy = (py+player.size/2)-(this.y+11);
                const dist = Math.sqrt(dx*dx+dy*dy);
                
                // è¿›å…¥è§¦å‘èŒƒå›´ï¼Œå¯åŠ¨å¼•ä¿¡
                if (dist < this.maxR && !this.fuseStarted && !this.exploding) {
                    this.fuseStarted = true;
                    this.fuseTime = 800; // 800mså»¶è¿Ÿå¼•çˆ†
                    return true;
                }
                return false;
            }
            hit(px, py) {
                // åªæœ‰çˆ†ç‚¸æ‰©æ•£é˜¶æ®µæ‰é€ æˆä¼¤å®³ï¼Œä¸”åªé€ æˆä¸€æ¬¡
                if (!this.exploding || this.hasDamaged) return 0;
                
                const dx = (px+player.size/2)-(this.x+11), dy = (py+player.size/2)-(this.y+11);
                if (Math.sqrt(dx*dx+dy*dy) < this.r) {
                    this.hasDamaged = true; // æ ‡è®°å·²é€ æˆä¼¤å®³
                    return 2;
                }
                return 0;
            }
        }
        
        class Coin {
            constructor(x, y) { this.x = x; this.y = y; this.s = 14; this.collected = false; this.o = Math.random() * Math.PI * 2; }
            draw(t) {
                if (this.collected) return;
                const cw = canvas.width;
                if (this.x + this.s < 0 || this.x > cw) return;
                const bob = Math.sin(t / 200 + this.o) * 3;
                ctx.save();
                ctx.shadowBlur = 12; ctx.shadowColor = '#ffd700';
                ctx.fillStyle = '#ffd700';
                ctx.beginPath(); ctx.arc(this.x + 7, this.y + 7 + bob, 7, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#ffed4a';
                ctx.beginPath(); ctx.arc(this.x + 7, this.y + 7 + bob, 4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
            collect(px, py) {
                if (this.collected) return false;
                const dx = (px + 9) - (this.x + 7), dy = (py + 9) - (this.y + 7);
                if (Math.sqrt(dx * dx + dy * dy) < 15) { this.collected = true; return true; }
                return false;
            }
        }
        
        // ==================== æ ¸å¿ƒå‡½æ•° ====================
        
        function initLevel(lvl) {
            level = lvl;
            // æ ¹æ®å…³å¡é˜¶æ®µè®¾ç½®ç”»å¸ƒå¤§å°
            if (lvl <= 40) {
                canvas.width = W;
                canvas.height = H;
                worldW = W;
                isScrolling = false;
            } else if (lvl <= 60) {
                canvas.width = 700;
                canvas.height = 450;
                worldW = 700;
                isScrolling = false;
            } else if (lvl <= 80) {
                canvas.width = 800;
                canvas.height = 500;
                worldW = 800;
                isScrolling = false;
            } else {
                canvas.width = 900;
                canvas.height = 550;
                worldW = 900;
                isScrolling = false;
            }
            
            camX = 0;
            
            // é‡ç½®æ‰€æœ‰æŒ‰é”®çŠ¶æ€
            Object.keys(keys).forEach(k => keys[k] = false);
            
            document.getElementById('progressBox').style.display = 'none';
            
            // é‡ç½®ç”Ÿå‘½å’Œæ—¶é—´
            lives = maxLives;
            levelTime = Math.max(30, 60 - Math.floor((lvl-1)/10)*3);
            
            // åº”ç”¨è´­ä¹°çš„é“å…·
            if (items.time > 0) { levelTime += 30; items.time--; }
            
            // é‡ç½®ç©å®¶
            player.x = 50; 
            player.y = Math.floor(canvas.height / 2) - 10;
            player.dizzy = 0;
            player.speed = items.speed > 0 ? 4.5 : 3;
            player.shield = items.shield > 0 ? 1 : 0;
            if (items.shield > 0) items.shield--;
            
            // æ›´æ–°ç»ˆç‚¹ä½ç½®
            endPt.x = worldW - 70;
            endPt.y = Math.floor(canvas.height / 2) - 20;
            
            // ç”Ÿæˆå…³å¡
            generateLevel(lvl);
            
            particles = [];
            updateUI();
        }
        
        // ç”Ÿæˆå®Œæ•´å…³å¡
        function generateLevel(lvl) {
            lasers = [];
            bombs = [];
            coinList = [];
            
            const cw = canvas.width;
            const ch = canvas.height;
            
            // åŸºç¡€å‚æ•°
            const baseInt = Math.max(400, 1600 - lvl * 12);
            const maxType = Math.min(4, Math.floor((lvl - 1) / 15));
            
            // ç¡®å®šé˜¶æ®µ
            const stage = Math.floor((lvl - 1) / 10) + 1; // 1-10
            
            if (stage === 1) {
                // ========== é˜¶æ®µ1ï¼šç›´çº¿é˜²çº¿ï¼ˆ1-10å…³ï¼‰==========
                generateStraightLine(lvl, cw, ch, baseInt, maxType);
            } else if (stage === 2) {
                // ========== é˜¶æ®µ2ï¼šåˆ†æ”¯é€‰æ‹©ï¼ˆ11-20å…³ï¼‰==========
                generateBranchPath(lvl, cw, ch, baseInt, maxType);
            } else if (stage === 3) {
                // ========== é˜¶æ®µ3ï¼šç¯å½¢è¿·å®«ï¼ˆ21-30å…³ï¼‰==========
                generateRingMaze(lvl, cw, ch, baseInt, maxType);
            } else if (stage === 4) {
                // ========== é˜¶æ®µ4ï¼šå¤šå±‚ç»“æ„ï¼ˆ31-40å…³ï¼‰==========
                generateMultiLayer(lvl, cw, ch, baseInt, maxType);
            } else if (stage === 5) {
                // ========== é˜¶æ®µ5ï¼šåŠ¨æ€é˜²çº¿ï¼ˆ41-50å…³ï¼‰==========
                generateDynamicDefense(lvl, cw, ch, baseInt, maxType, true);
            } else if (stage === 6) {
                // ========== é˜¶æ®µ6ï¼šæé™æŒ‘æˆ˜ï¼ˆ51-60å…³ï¼‰==========
                generateDynamicDefense(lvl, cw, ch, baseInt, maxType, true);
            } else if (stage === 7) {
                // ========== é˜¶æ®µ7ï¼šå¿«é€ŸåŠ¨æ€ï¼ˆ61-70å…³ï¼‰==========
                generateDynamicDefense(lvl, cw, ch, baseInt * 0.8, maxType, true);
            } else if (stage === 8) {
                // ========== é˜¶æ®µ8ï¼šç»„åˆæ¿€å…‰ï¼ˆ71-80å…³ï¼‰==========
                generateComboLasers(lvl, cw, ch, baseInt * 0.7, maxType);
            } else if (stage === 9) {
                // ========== é˜¶æ®µ9ï¼šæé™ç»„åˆï¼ˆ81-90å…³ï¼‰==========
                generateComboLasers(lvl, cw, ch, baseInt * 0.6, maxType);
            } else {
                // ========== é˜¶æ®µ10ï¼šå¤§å¸ˆæ¨¡å¼ï¼ˆ91-100å…³ï¼‰==========
                generateMasterMode(lvl, cw, ch, baseInt * 0.5, maxType);
            }
            
            // ç”Ÿæˆç‚¸å¼¹
            if (lvl >= 5) {
                const bc = Math.min(5, 1 + Math.floor(lvl / 12));
                for (let i = 0; i < bc; i++) {
                    const x = 150 + Math.random() * (worldW - 300);
                    const y = 60 + Math.random() * (ch - 120);
                    if (Math.abs(x - 50) > 60 && Math.abs(x - endPt.x) > 60) {
                        bombs.push(new Bomb(x, y));
                    }
                }
            }
            
            // ç”Ÿæˆé‡‘å¸
            const cc = 2 + Math.floor((lvl - 1) / 10) * 2;
            let attempts = 0;
            while (coinList.length < cc && attempts < cc * 5) {
                attempts++;
                const x = 100 + Math.random() * (worldW - 200);
                const y = 50 + Math.random() * (ch - 100);
                if (Math.abs(x - 50) > 40 && Math.abs(x - endPt.x) > 40) {
                    coinList.push(new Coin(x, y));
                }
            }
        }
        
        // é˜¶æ®µ1ï¼šç›´çº¿é˜²çº¿
        function generateStraightLine(lvl, cw, ch, baseInt, maxType) {
            const numKey = Math.min(4, 2 + Math.floor(lvl / 5));
            const numAux = Math.min(5, 2 + Math.floor(lvl / 3));
            
            // å…³é”®æ¿€å…‰ - å‚ç›´é˜²çº¿ï¼ˆå¿…é¡»ç©¿è¶Šï¼‰
            const startX = 120;
            const endX = cw - 120;
            const spacing = (endX - startX) / (numKey + 1);
            
            for (let i = 0; i < numKey; i++) {
                const x = startX + (i + 1) * spacing;
                const type = Math.min(maxType, Math.floor(i / 2));
                
                // å…³é”®æ¿€å…‰ï¼šå®Œæ•´å‚ç›´è´¯ç©¿ï¼Œä¸­é—´ç•™é€šé“
                const passageY = 60 + ((lvl * 17 + i * 31) % (ch - 140));
                const passageHeight = Math.max(50, 90 - lvl * 3);
                
                // æ ‡è®°ä¸ºå…³é”®æ¿€å…‰ï¼ˆé€šè¿‡extendedå±æ€§ï¼‰
                const upper = new Laser(x, 0, 5, passageY, type, baseInt, i * 150);
                upper.isKey = true;
                lasers.push(upper);
                
                const lower = new Laser(x, passageY + passageHeight, 5, ch - passageY - passageHeight, type, baseInt, i * 150 + baseInt / 2);
                lower.isKey = true;
                lasers.push(lower);
            }
            
            // è¾…åŠ©æ¿€å…‰ - æ¨ªå‘å¹²æ‰°ï¼ˆå¯ç»•è¿‡ï¼‰
            for (let i = 0; i < numAux; i++) {
                const y = 80 + ((lvl * 23 + i * 37) % (ch - 160));
                const gapX = 100 + ((lvl * 29 + i * 43) % (cw - 300));
                const gapWidth = 80 + ((lvl * 11 + i) % 40);
                
                // å·¦æ®µ
                lasers.push(new Laser(0, y, gapX, 4, Math.min(2, maxType), baseInt * 1.2, i * 200));
                // å³æ®µ
                lasers.push(new Laser(gapX + gapWidth, y, cw - gapX - gapWidth, 4, Math.min(2, maxType), baseInt * 1.2, i * 200 + baseInt / 3));
            }
        }
        
        // é˜¶æ®µ2ï¼šåˆ†æ”¯é€‰æ‹©
        function generateBranchPath(lvl, cw, ch, baseInt, maxType) {
            // ç¬¬ä¸€é“å…³é”®æ¿€å…‰ï¼ˆå…¥å£ï¼‰
            const entryX = 150;
            const type1 = Math.min(maxType, 0);
            const passageY1 = Math.floor(ch / 3);
            const passageH1 = Math.max(50, 85 - lvl * 2);
            
            const key1a = new Laser(entryX, 0, 5, passageY1, type1, baseInt, 0);
            key1a.isKey = true;
            lasers.push(key1a);
            const key1b = new Laser(entryX, passageY1 + passageH1, 5, ch - passageY1 - passageH1, type1, baseInt, baseInt / 2);
            key1b.isKey = true;
            lasers.push(key1b);
            
            // åˆ†æ”¯ç‚¹åçš„ç¬¬äºŒé“å…³é”®æ¿€å…‰
            const branchX = cw - 180;
            const type2 = Math.min(maxType, 1);
            
            // ä¸Šåˆ†æ”¯é€šé“
            const upperPassageY = Math.floor(ch / 4);
            const upperPassageH = Math.max(45, 75 - lvl * 2);
            const key2a_upper = new Laser(branchX, 0, 5, upperPassageY, type2, baseInt, 200);
            key2a_upper.isKey = true;
            lasers.push(key2a_upper);
            const key2b_upper = new Laser(branchX, upperPassageY + upperPassageH, 5, ch / 2 - upperPassageY - upperPassageH, type2, baseInt, 200 + baseInt / 2);
            key2b_upper.isKey = true;
            lasers.push(key2b_upper);
            
            // ä¸‹åˆ†æ”¯é€šé“
            const lowerPassageY = Math.floor(ch * 3 / 4) - upperPassageH;
            const key2a_lower = new Laser(branchX, ch / 2, 5, lowerPassageY - ch / 2, type2, baseInt, 300);
            key2a_lower.isKey = true;
            lasers.push(key2a_lower);
            const key2b_lower = new Laser(branchX, lowerPassageY + upperPassageH, 5, ch - lowerPassageY - upperPassageH, type2, baseInt, 300 + baseInt / 2);
            key2b_lower.isKey = true;
            lasers.push(key2b_lower);
            
            // è¾…åŠ©æ¿€å…‰ - å¸ƒç½®åœ¨åˆ†æ”¯è·¯å¾„ä¸Šå¢åŠ é€‰æ‹©éš¾åº¦
            // ä¸Šè·¯å¾„éšœç¢ï¼ˆå±é™©ä½†çŸ­ï¼‰
            for (let i = 0; i < 3; i++) {
                const x = 200 + i * 50;
                const y = Math.floor(ch / 4) - 30 + ((lvl + i) % 3) * 20;
                lasers.push(new Laser(x, y, 40, 4, 0, baseInt * 0.8, i * 100));
            }
            
            // ä¸‹è·¯å¾„éšœç¢ï¼ˆå®‰å…¨ä½†é•¿ï¼‰
            for (let i = 0; i < 2; i++) {
                const x = 220 + i * 80;
                const y = Math.floor(ch * 3 / 4) - 20;
                lasers.push(new Laser(x, y, 60, 4, 0, baseInt * 0.9, i * 150));
            }
        }
        
        // é˜¶æ®µ3ï¼šç¯å½¢è¿·å®«
        function generateRingMaze(lvl, cw, ch, baseInt, maxType) {
            const numKey = 3;
            const centerX = Math.floor(cw / 2);
            const centerY = Math.floor(ch / 2);
            
            // å…³é”®æ¿€å…‰å½¢æˆä¸‰è§’å½¢/ç¯å½¢
            // å…³é”®1ï¼šå·¦ä¾§å‚ç›´
            const key1X = centerX - 100;
            const passageY1 = centerY - 40;
            const passageH = Math.max(45, 75 - lvl * 2);
            const k1a = new Laser(key1X, 0, 5, passageY1, maxType, baseInt, 0);
            k1a.isKey = true;
            lasers.push(k1a);
            const k1b = new Laser(key1X, passageY1 + passageH, 5, ch - passageY1 - passageH, maxType, baseInt, baseInt / 2);
            k1b.isKey = true;
            lasers.push(k1b);
            
            // å…³é”®2ï¼šå³ä¸Šæ–œå‘
            const key2X = centerX + 50;
            const passageY2 = 60;
            const k2a = new Laser(key2X, 0, 5, passageY2, maxType, baseInt, 150);
            k2a.isKey = true;
            lasers.push(k2a);
            const k2b = new Laser(key2X, passageY2 + passageH, 5, centerY - 60 - passageH, maxType, baseInt, 150 + baseInt / 2);
            k2b.isKey = true;
            lasers.push(k2b);
            
            // å…³é”®3ï¼šå³ä¸‹æ–œå‘
            const key3X = centerX + 80;
            const passageY3 = centerY + 40;
            const k3a = new Laser(key3X, centerY + 40, 5, passageY3 - centerY - 40, maxType, baseInt, 300);
            k3a.isKey = true;
            lasers.push(k3a);
            const k3b = new Laser(key3X, passageY3 + passageH, 5, ch - passageY3 - passageH, maxType, baseInt, 300 + baseInt / 2);
            k3b.isKey = true;
            lasers.push(k3b);
            
            // è¾…åŠ©æ¿€å…‰ - ç¯å½¢éšœç¢
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const radius = 80 + ((lvl + i) % 3) * 15;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                if (x > 50 && x < cw - 50 && y > 50 && y < ch - 50) {
                    lasers.push(new Laser(x, y, 30, 4, Math.min(1, maxType), baseInt * 0.9, i * 100));
                }
            }
        }
        
        // é˜¶æ®µ4ï¼šå¤šå±‚ç»“æ„
        function generateMultiLayer(lvl, cw, ch, baseInt, maxType) {
            // æ¯å±‚é«˜åº¦
            const layerHeight = Math.floor(ch / 3);
            
            // ç¬¬ä¸€å±‚å…¥å£
            const key1Y = layerHeight;
            const passageX1 = 80 + ((lvl * 13) % (cw - 200));
            const k1a = new Laser(0, key1Y, passageX1, 5, maxType, baseInt, 0);
            k1a.isKey = true;
            lasers.push(k1a);
            const k1b = new Laser(passageX1 + 60, key1Y, cw - passageX1 - 60, 5, maxType, baseInt, baseInt / 2);
            k1b.isKey = true;
            lasers.push(k1b);
            
            // ç¬¬äºŒå±‚åˆ†éš”
            const key2Y = layerHeight * 2;
            const passageX2 = 100 + ((lvl * 29) % (cw - 250));
            const k2a = new Laser(0, key2Y, passageX2, 5, maxType, baseInt, 200);
            k2a.isKey = true;
            lasers.push(k2a);
            const k2b = new Laser(passageX2 + 55, key2Y, cw - passageX2 - 55, 5, maxType, baseInt, 200 + baseInt / 2);
            k2b.isKey = true;
            lasers.push(k2b);
            
            // ç¬¬ä¸‰å±‚å‡ºå£
            const key3Y = ch - 60;
            const passageX3 = 90 + ((lvl * 37) % (cw - 220));
            const k3a = new Laser(0, key3Y, passageX3, 5, maxType, baseInt, 400);
            k3a.isKey = true;
            lasers.push(k3a);
            const k3b = new Laser(passageX3 + 65, key3Y, cw - passageX3 - 65, 5, maxType, baseInt, 400 + baseInt / 2);
            k3b.isKey = true;
            lasers.push(k3b);
            
            // æ¯å±‚å†…éƒ¨çš„è¾…åŠ©æ¿€å…‰
            for (let layer = 0; layer < 3; layer++) {
                const yBase = layer * layerHeight + 40;
                for (let i = 0; i < 3; i++) {
                    const x = 150 + i * 120 + ((lvl + layer * 10 + i) % 40);
                    const y = yBase + ((lvl + i) % (layerHeight - 80));
                    lasers.push(new Laser(x, y, 40, 4, Math.min(2, maxType), baseInt * 1.1, layer * 300 + i * 100));
                }
            }
        }
        
        // é˜¶æ®µ5-7ï¼šåŠ¨æ€é˜²çº¿
        function generateDynamicDefense(lvl, cw, ch, baseInt, maxType, hasMovement) {
            const numKey = Math.min(5, 3 + Math.floor((lvl - 40) / 10));
            
            // å…³é”®æ¿€å…‰ - å‚ç›´é˜²çº¿
            const startX = 140;
            const endX = cw - 140;
            const spacing = (endX - startX) / (numKey + 1);
            
            for (let i = 0; i < numKey; i++) {
                const x = startX + (i + 1) * spacing;
                const type = Math.min(maxType, Math.floor((lvl - 40) / 10) + Math.floor(i / 2));
                
                const passageY = 60 + ((lvl * 17 + i * 31 + Math.floor(Date.now() / 1000)) % (ch - 140));
                const passageHeight = Math.max(40, 70 - (lvl - 40) * 0.5);
                
                const k1 = new Laser(x, 0, 5, passageY, type, baseInt, i * 120);
                k1.isKey = true;
                if (hasMovement) k1.moveSpeed = 0.5 + (lvl - 40) * 0.05;
                lasers.push(k1);
                
                const k2 = new Laser(x, passageY + passageHeight, 5, ch - passageY - passageHeight, type, baseInt, i * 120 + baseInt / 2);
                k2.isKey = true;
                if (hasMovement) k2.moveSpeed = 0.5 + (lvl - 40) * 0.05;
                lasers.push(k2);
            }
            
            // å¤§é‡è¾…åŠ©æ¿€å…‰
            const numAux = Math.min(14, 8 + Math.floor((lvl - 40) / 5));
            for (let i = 0; i < numAux; i++) {
                const isVertical = i % 2 === 0;
                if (isVertical) {
                    const x = 120 + ((lvl * 23 + i * 41) % (cw - 240));
                    const gapY = 80 + ((lvl * 29 + i * 37) % (ch - 160));
                    lasers.push(new Laser(x, 0, 5, gapY, Math.min(2, maxType), baseInt * 0.9, i * 80));
                    lasers.push(new Laser(x, gapY + 50, 5, ch - gapY - 50, Math.min(2, maxType), baseInt * 0.9, i * 80 + baseInt / 3));
                } else {
                    const y = 60 + ((lvl * 31 + i * 43) % (ch - 120));
                    lasers.push(new Laser(0, y, cw, 4, Math.min(2, maxType), baseInt * 1.1, i * 100));
                }
            }
        }
        
        // é˜¶æ®µ8-9ï¼šç»„åˆæ¿€å…‰
        function generateComboLasers(lvl, cw, ch, baseInt, maxType) {
            const numGroups = 4;
            const groupSpacing = (cw - 300) / numGroups;
            
            for (let g = 0; g < numGroups; g++) {
                const groupX = 150 + g * groupSpacing;
                
                // æ¯ç»„ï¼šå…³é”®æ¿€å…‰ + è¾…åŠ©æ¿€å…‰ç»„åˆ
                const passageY = 60 + ((lvl * 19 + g * 47) % (ch - 140));
                const passageH = Math.max(35, 60 - (lvl - 70) * 0.5);
                
                // å…³é”®æ¿€å…‰ï¼ˆå¿…é¡»è¿ç»­ç©¿è¶Šï¼‰
                for (let i = 0; i < 2; i++) {
                    const x = groupX + i * 15;
                    const k1 = new Laser(x, 0, 5, passageY, maxType, baseInt, g * 200 + i * 50);
                    k1.isKey = true;
                    lasers.push(k1);
                    const k2 = new Laser(x, passageY + passageH, 5, ch - passageY - passageH, maxType, baseInt, g * 200 + i * 50 + baseInt / 2);
                    k2.isKey = true;
                    lasers.push(k2);
                }
            }
            
            // è¾…åŠ©æ¿€å…‰ç½‘æ ¼
            for (let i = 0; i < 12; i++) {
                const x = 100 + ((lvl * 17 + i * 29) % (cw - 200));
                const y = 60 + ((lvl * 23 + i * 31) % (ch - 120));
                lasers.push(new Laser(x, y, 35, 3, Math.min(3, maxType), baseInt * 0.8, i * 60));
            }
        }
        
        // é˜¶æ®µ10ï¼šå¤§å¸ˆæ¨¡å¼
        function generateMasterMode(lvl, cw, ch, baseInt, maxType) {
            // æé™éš¾åº¦ï¼šå¿«é€Ÿåˆ‡æ¢ + å¤§é‡æ¿€å…‰ + éšæœºå…ƒç´ 
            generateComboLasers(lvl, cw, ch, baseInt, maxType);
            
            // æ·»åŠ é¢å¤–çš„å¹²æ‰°æ¿€å…‰
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * (cw - 100) + 50;
                const y = Math.random() * (ch - 100) + 50;
                const w = 20 + Math.random() * 40;
                const h = 3;
                lasers.push(new Laser(x, y, w, h, maxType, baseInt * 0.6, i * 40));
            }
        }
                const numBarriers = 4 + Math.floor((lvl - 20) / 12);
                const barrierSpacing = (worldW - 400) / numBarriers;
                
                for (let i = 0; i < numBarriers; i++) {
                    const barrierX = 200 + i * barrierSpacing;
                    const laserType = Math.min(maxType, Math.floor(i / 2));
                    const barrierType = (lvl + i) % 3;
                    
                    if (barrierType === 0) {
                        // ä¸­å¤®å•é€šé“
                        const passageY = H / 2 - passageWidth / 2 + ((lvl * 7 + i * 13) % 40 - 20);
                        lasers.push(new Laser(barrierX, 0, 5, passageY, laserType, baseInt, i * 100));
                        lasers.push(new Laser(barrierX, passageY + passageWidth, 5, H - passageY - passageWidth, laserType, baseInt, i * 100 + baseInt / 2));
                    } else if (barrierType === 1) {
                        // ä¸Šä¸‹åŒé€šé“
                        const upperY = 60 + ((lvl * 17 + i * 29) % (H / 2 - passageWidth - 80));
                        const lowerY = H / 2 + 40 + ((lvl * 23 + i * 31) % (H / 2 - passageWidth - 80));
                        
                        lasers.push(new Laser(barrierX, 0, 5, upperY, laserType, baseInt, i * 120));
                        lasers.push(new Laser(barrierX, upperY + passageWidth, 5, lowerY - upperY - passageWidth, laserType, baseInt, i * 120 + baseInt / 3));
                        lasers.push(new Laser(barrierX, lowerY + passageWidth, 5, H - lowerY - passageWidth, laserType, baseInt, i * 120 + baseInt * 2 / 3));
                    } else {
                        // åŠ¨æ€åç§»é€šé“
                        const passageY = 80 + ((lvl * 19 + i * 37) % (H - passageWidth - 160));
                        const offset = (i % 2 === 0) ? -20 : 20;
                        lasers.push(new Laser(barrierX + offset, 0, 5, passageY, laserType, baseInt, i * 140));
                        lasers.push(new Laser(barrierX - offset, passageY + passageWidth, 5, H - passageY - passageWidth, laserType, baseInt, i * 140 + baseInt / 2));
                    }
                }
            }
            
            // ç”Ÿæˆç‚¸å¼¹ - 5å…³åæ‰æœ‰
            bombs = []; 
            if (lvl >= 5) {
                const bc = Math.min(5, 1 + Math.floor(lvl/12));
                for (let i=0; i<bc; i++) {
                    const x = 100 + Math.random()*(worldW-200);
                    const y = 60 + Math.random()*(canvas.height-120);
                    if (Math.abs(x-50)>60 && Math.abs(x-endPt.x)>60) bombs.push(new Bomb(x, y));
                }
            }
            
            // ç”Ÿæˆé‡‘å¸ - ç¡®ä¿ç”ŸæˆæŒ‡å®šæ•°é‡
            coinList = []; 
            const cc = 2 + Math.floor((lvl-1)/10)*2;
            let attempts = 0;
            while (coinList.length < cc && attempts < cc * 3) {
                attempts++;
                const x = 80 + Math.random()*(worldW-160);
                const y = 60 + Math.random()*(canvas.height-120);
                // æ£€æŸ¥æ˜¯å¦ä¸èµ·ç‚¹ç»ˆç‚¹å¤ªè¿‘
                if (Math.abs(x-50) < 50) continue;
                if (Math.abs(x-endPt.x) < 50) continue;
                coinList.push(new Coin(x, y));
            }
            
            particles = [];
            updateUI();
        }
        
        function updateUI() {
            document.getElementById('lives').textContent = lives;
            document.getElementById('timer').textContent = levelTime;
            document.getElementById('level').textContent = level;
            document.getElementById('coins').textContent = coins;
        }
        
        function update(dt) {
            if (gameState !== 'playing') return;
            
            if (player.dizzy > 0) player.dizzy -= dt;
            
            // ç§»åŠ¨
            let dx = 0, dy = 0;
            if (player.dizzy <= 0) {
                if (keys['ArrowUp'] || keys['w']) dy = -player.speed;
                if (keys['ArrowDown'] || keys['s']) dy = player.speed;
                if (keys['ArrowLeft'] || keys['a']) dx = -player.speed;
                if (keys['ArrowRight'] || keys['d']) dx = player.speed;
            } else {
                dx = (Math.random()-0.5)*player.speed;
                dy = (Math.random()-0.5)*player.speed;
            }
            player.x += dx; player.y += dy;
            player.x = Math.max(0, Math.min(worldW - player.size, player.x));
            player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));
            
            // æ›´æ–°å¯¹è±¡
            lasers.forEach(l => l.update(dt, level));
            bombs = bombs.filter(b => {
                const alive = b.update(dt);
                if (b.trigger(player.x, player.y)) {
                    for(let i=0; i<8; i++) particles.push({x:b.x+11, y:b.y+11, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:25, c:'#ff4400'});
                }
                return alive;
            });
            particles = particles.filter(p => { p.x+=p.vx; p.y+=p.vy; p.life--; return p.life>0; });
            
            // ç¢°æ’æ£€æµ‹
            let dmg = 0;
            lasers.forEach(l => dmg += l.hit(player.x, player.y));
            bombs.forEach(b => dmg += b.hit(player.x, player.y));
            
            if (dmg > 0) {
                if (player.shield > 0) { player.shield = 0; dmg = 0; }
                lives -= dmg;
                if (bombs.some(b => b.hit(player.x, player.y) > 0)) player.dizzy = 1500;
                updateUI();
                player.x = 50; player.y = Math.floor(canvas.height / 2) - 10;
                if (lives <= 0) gameOver();
            }
            
            // æ”¶é›†é‡‘å¸
            coinList.forEach(c => {
                if (c.collect(player.x, player.y)) {
                    coins++;
                    for(let i=0; i<5; i++) particles.push({x:c.x+7, y:c.y+7, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:20, c:'#ffd700'});
                    updateUI();
                }
            });
            
            // åˆ°è¾¾ç»ˆç‚¹
            const ex = endPt.x;
            if (player.x+player.size > ex && player.x < ex+endPt.w &&
                player.y+player.size > endPt.y && player.y < endPt.y+endPt.h) {
                levelComplete();
            }
        }
        
        function draw() {
            const cw = canvas.width;
            const ch = canvas.height;
            
            ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, cw, ch);
            
            // ç½‘æ ¼
            ctx.strokeStyle = 'rgba(0,212,255,0.05)';
            for (let x = 0; x < cw; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, ch); ctx.stroke(); }
            for (let y = 0; y < ch; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cw, y); ctx.stroke(); }
            
            // èµ·ç‚¹
            const ssx = startPt.x;
            ctx.fillStyle = '#00ff88'; ctx.shadowBlur = 15; ctx.shadowColor = '#00ff88';
            ctx.fillRect(ssx, startPt.y, startPt.w, startPt.h);
            ctx.fillStyle = '#000'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.shadowBlur = 0;
            ctx.fillText('èµ·', ssx + 20, startPt.y + 25);
            
            // ç»ˆç‚¹
            const esx = endPt.x;
            ctx.fillStyle = '#ff0066'; ctx.shadowBlur = 15; ctx.shadowColor = '#ff0066';
            ctx.fillRect(esx, endPt.y, endPt.w, endPt.h);
            ctx.fillStyle = '#fff'; ctx.fillText('ç»ˆ', esx + 20, endPt.y + 25); ctx.shadowBlur = 0;
            
            // æ¸¸æˆå¯¹è±¡
            lasers.forEach(l => l.draw());
            bombs.forEach(b => b.draw());
            coinList.forEach(c => c.draw(performance.now()));
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 25; ctx.fillStyle = p.c;
                ctx.fillRect(p.x, p.y, 4, 4); ctx.globalAlpha = 1;
            });
            
            // ç©å®¶
            ctx.save(); ctx.shadowBlur = 12; ctx.shadowColor = player.color;
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.size, player.size);
            if (player.shield > 0) {
                ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(player.x + 9, player.y + 9, 16, 0, Math.PI * 2); ctx.stroke();
            }
            if (player.dizzy > 0) { ctx.font = '14px Arial'; ctx.fillText('ğŸ’«', player.x + 9, player.y - 5); }
            ctx.restore();
        }
        
        // æ¸¸æˆå¾ªç¯æ§åˆ¶
        let gameLoopId = null;
        
        function gameLoop(ts) {
            if (gameState !== 'playing') { gameLoopId = null; return; }
            const dt = ts - lastTime; lastTime = ts;
            update(dt); draw();
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        function startGameLoop() {
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            lastTime = performance.now();
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        // ==================== æ¸¸æˆæ§åˆ¶ ====================
        
        function startGame() {
            const startLvl = parseInt(document.getElementById('levelSlider').value);
            document.getElementById('levelSelectScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('actionBtn').textContent = 'é‡æ–°å¼€å§‹';
            gameState = 'playing';
            level = startLvl; lives = maxLives; coins = 0; totalTime = 0;
            Object.keys(items).forEach(k => items[k] = 0);
            Object.keys(keys).forEach(k => keys[k] = false);
            initLevel(startLvl);
            startGameLoop();
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (gameState === 'playing') {
                    levelTime--; totalTime++;
                    if (levelTime <= 0) gameOver();
                    updateUI();
                }
            }, 1000);
        }
        
        function showLevelSelect() {
            const maxLvl = Math.max(1, maxLevelReached);
            document.getElementById('selectMaxLevel').textContent = maxLvl;
            document.getElementById('levelSlider').max = maxLvl;
            document.getElementById('levelSlider').value = 1;
            document.getElementById('selectedLevel').textContent = '1';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('levelSelectScreen').style.display = 'block';
        }
        
        function confirmStartLevel() {
            startGame();
        }
        
        function backToMenu() {
            document.getElementById('levelSelectScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        }
        
        function levelComplete() {
            clearInterval(timerInterval);
            saveMaxLevel(level);
            if (level % 10 === 0) { showShop(); return; }
            if (level >= 100) { victory(); return; }
            level++;
            initLevel(level);
            startGameLoop();
            timerInterval = setInterval(() => {
                if (gameState === 'playing') {
                    levelTime--; totalTime++;
                    if (levelTime <= 0) gameOver();
                    updateUI();
                }
            }, 1000);
        }
        
        function gameOver() {
            gameState = 'over'; clearInterval(timerInterval);
            saveMaxLevel(level);
            document.getElementById('goTitle').textContent = 'æ¸¸æˆç»“æŸ';
            document.getElementById('goTitle').style.color = '#ff6b6b';
            document.getElementById('goStats').innerHTML = `å…³å¡: ${level}/100<br>ç”¨æ—¶: ${Math.floor(totalTime/60)}åˆ†${totalTime%60}ç§’<br>é‡‘å¸: ${coins}`;
            
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        
        function victory() {
            gameState = 'victory'; clearInterval(timerInterval);
            document.getElementById('goTitle').textContent = 'ğŸ‰ é€šå…³ï¼';
            document.getElementById('goTitle').style.color = '#00ff88';
            document.getElementById('goStats').innerHTML = `æ­å–œé€šè¿‡100å…³ï¼<br>æ€»ç”¨æ—¶: ${Math.floor(totalTime/60)}åˆ†${totalTime%60}ç§’`;
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        
        // ==================== å•†åº— ====================
        
        function showShop() {
            gameState = 'shop';
            document.getElementById('shopCoins').textContent = coins;
            const container = document.getElementById('shopItems');
            container.innerHTML = `
                <div class="shop-item" onclick="buy('speed',10)">âš¡ åŠ é€Ÿé´<br><small>10ğŸª™ é€Ÿåº¦+50%</small></div>
                <div class="shop-item" onclick="buy('shield',15)">ğŸ›¡ï¸ é˜²æŠ¤ç›¾<br><small>15ğŸª™ æŠµæŒ¡ä¼¤å®³</small></div>
                <div class="shop-item" onclick="buy('life',8)">â¤ï¸ ç”Ÿå‘½è¯æ°´<br><small>8ğŸª™ +2ç”Ÿå‘½</small></div>
                <div class="shop-item" onclick="buy('time',12)">â±ï¸ æ—¶é—´æ²™æ¼<br><small>12ğŸª™ +30ç§’</small></div>
            `;
            document.getElementById('shopScreen').style.display = 'block';
        }
        
        function buy(type, price) {
            if (coins >= price) {
                if (type === 'life') {
                    // ç”Ÿå‘½è¯æ°´ï¼šæ°¸ä¹…å¢åŠ æœ€å¤§ç”Ÿå‘½å€¼+2
                    maxLives += 2;
                    updateUI();
                } else {
                    items[type]++;
                }
                coins -= price;
                document.getElementById('shopCoins').textContent = coins;
                updateUI();
            }
        }
        
        function closeShop() {
            document.getElementById('shopScreen').style.display = 'none';
            // ä»å•†åº—å…³è¿›å…¥ä¸‹ä¸€å…³
            nextLevelAfterShop();
        }
        
        function nextLevelAfterShop() {
            gameState = 'playing'; // ç¡®ä¿æ¸¸æˆçŠ¶æ€æ­£ç¡®
            clearInterval(timerInterval);
            if (level >= 100) { victory(); return; }
            level++;
            initLevel(level);
            startGameLoop();
            timerInterval = setInterval(() => {
                if (gameState === 'playing') {
                    levelTime--; totalTime++;
                    if (levelTime <= 0) gameOver();
                    updateUI();
                }
            }, 1000);
        }
        
        // ==================== æ’è¡Œæ¦œ ====================
        
        function submitScore() {
            const name = document.getElementById('playerName').value.trim() || 'åŒ¿å';
            lb.push({name, level, time: totalTime, coins, date: new Date().toLocaleDateString()});
            lb.sort((a,b) => b.level !== a.level ? b.level - a.level : a.time - b.time);
            lb = lb.slice(0, 20);
            localStorage.setItem('lb100', JSON.stringify(lb));
            document.getElementById('gameOverScreen').style.display = 'none';
            showLeaderboard();
        }
        
        function skipSubmit() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        }
        
        function restartFromLevel() {
            showLevelSelect();
        }
        
        function showLeaderboard() {
            const c = document.getElementById('lbContent');
            if (lb.length === 0) {
                c.innerHTML = '<p style="color:#888">æš‚æ— è®°å½•</p>';
            } else {
                // åªæ˜¾ç¤ºå‰7å
                const displayLb = lb.slice(0, 7);
                let html = '<table><tr><th>æ’å</th><th>ç©å®¶</th><th>å…³å¡</th><th>ç”¨æ—¶</th></tr>';
                displayLb.forEach((e, i) => {
                    const m = Math.floor(e.time / 60), s = e.time % 60;
                    html += `<tr><td>${i < 3 ? ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'][i] : i + 1}</td><td>${e.name}</td><td>${e.level}</td><td>${m}åˆ†${s}ç§’</td></tr>`;
                });
                html += '</table>';
                if (lb.length > 7) {
                    html += `<p style="color:#888;font-size:11px;margin-top:5px;">...è¿˜æœ‰${lb.length - 7}æ¡è®°å½•</p>`;
                }
                c.innerHTML = html;
            }
            document.getElementById('lbScreen').style.display = 'block';
        }
        
        function hideLeaderboard() {
            document.getElementById('lbScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        }
        
        // ==================== è¾“å…¥ ====================
        
        document.addEventListener('keydown', e => { if(gameState === 'playing') keys[e.key] = true; });
        document.addEventListener('keyup', e => { keys[e.key] = false; });
        
        // è§¦æ‘¸æ§åˆ¶ - ä¿®å¤é‡Šæ”¾é—®é¢˜
        const dPadMap = {
            'btnUp': 'ArrowUp',
            'btnDown': 'ArrowDown', 
            'btnLeft': 'ArrowLeft',
            'btnRight': 'ArrowRight'
        };
        
        Object.entries(dPadMap).forEach(([id, key]) => {
            const btn = document.getElementById(id);
            
            const onPress = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if(gameState === 'playing') keys[key] = true;
                btn.style.transform = 'scale(0.9)';
                btn.style.background = '#0077aa';
            };
            
            const onRelease = (e) => {
                e.preventDefault();
                e.stopPropagation();
                keys[key] = false;
                btn.style.transform = '';
                btn.style.background = '';
            };
            
            // è§¦æ‘¸äº‹ä»¶
            btn.addEventListener('touchstart', onPress, {passive: false});
            btn.addEventListener('touchend', onRelease, {passive: false});
            btn.addEventListener('touchcancel', onRelease, {passive: false});
            
            // é¼ æ ‡äº‹ä»¶
            btn.addEventListener('mousedown', onPress);
            btn.addEventListener('mouseup', onRelease);
            btn.addEventListener('mouseleave', onRelease);
        });
        
        document.getElementById('actionBtn').addEventListener('click', () => {
            if (gameState === 'playing') showLevelSelect();
            else showLevelSelect();
        });
        
        // é˜²æ­¢è§¦æ‘¸æ»šåŠ¨
        document.getElementById('dPad').addEventListener('touchmove', e => e.preventDefault(), {passive: false});
        
        // æ›´æ–°å¼€å§‹ç•Œé¢çš„å…³å¡é€‰æ‹©
        function updateStartScreen() {
            const maxLvl = Math.max(1, maxLevelReached);
        }
        
        // åˆå§‹ç»˜åˆ¶å’Œæ›´æ–°å¼€å§‹ç•Œé¢
        updateStartScreen();
        initLevel(1); 
        draw();
    </script>
</body>
</html>